# SpringMVC手写框架总结

![QQ图片20191111194808](G:\群硕实训\群硕项目\QQ图片20191111194808.png)

## 看门大爷——Filter

filter，中文解释过滤器。听名字就知道是放在最前面用来过滤的。可设置特定的格式，比喻一下就是滤网洞洞的不一样，但这个过滤器和生活中的过滤还是不一样的，生活中我们是过滤后丢掉，这里我们是过滤下来，进行一些处理，处理完之后还会放行。

例：PageEncodingFilter，中文释义“页面编码过滤器”，在我们这个项目中其功能就是过滤掉所有的.action请求，将其编码统一配置为UTF-8，配置完成后放行，继续后面的服务。

## 前端处理器——DispatcherServlet

之所以说DispatcherServlet是前端处理器是因为DispatcherServlet的主要功能就是负责前后端交互，将前端的request请求封装到map中，通过反射调用相应的Controller方法，并将处理好的封装在ModelAndView中的数据取出，还给response返回到前端页面。在这一层中，涉及到很多类的初始化。

- DispatcherServlet 
- BeanFactory
- 每层部分类

本部分讲解前两个初始化

### DispantcherServlet初始化

init是初始化方法，在此部分，我们将使用dom方式解析action.xml文件，将每一个action节点的数据分别封装到ActionConfig中，然后作为Value存入集合类Map中。

### BeanFactory初始化

Servlet的声命周期是，在服务器启动或者第一次处理请求时进行初始化，然后是service方法，由service决定是什么请求，进入请求方法，最后在destory方法进行销毁。而，BeanFaction第一次被使用就是在DispantcherServlet的service方法中

![1573476701641](G:\群硕实训\群硕项目\1573476701641.png)

在这里我们使用类名调用BeanFactory的getInstance方法来获取BeanFactory实例，相当于new。至于为什么static可以用类名调用，不用纠结，记住是java规定就好。而后我们通过获取的实例，调用其getBean方法，获取到需要的类。但究竟是怎么获取的，方法是怎么执行的，我们来看一下BeanFactory中的方法代码。

![1573477205982](G:\群硕实训\群硕项目\1573477205982.png)

因为是第一次使用，所以我们new出了beanFactory，而后在init方法中，我们第一次也仅此一次加载bean.xml。

![1573478190011](G:\群硕实训\群硕项目\1573478190011.png)为什么只会加载一次？因为这里是单例模式，beanFactory是强引用（这里知道就好），只要服务器不宕机，beanFactory是不会被回收的，也就是不会为null。

## 工厂生产实例

返回一个工厂实例，那么我们就可以调用它的非静态方法getBean

![1573477804610](G:\群硕实训\群硕项目\1573477804610.png)

在这里我们看到传入参数是id，也就是你所需要类的类名。beans保存的是bean.xml里的信息，通过id可以知道这个类在工厂里是否是单例生产。objects保存的是工厂所生产过的单例类，key依然是id也就是类名。Object，getBean的返回类型是一个Object，不是工厂实例，是你所需要的类，通过反射获取。

反射不用多讲，重要的是处理依赖关系

![1573478949973](G:\群硕实训\群硕项目\1573478949973.png)

在 Object refObject = this.getBean(ref);这里发生了递归，getBean获取我们所依赖的类的实例，然而如果我们所依赖的类仍然有所依赖的类我们继续getBean获取，直到所获取的类的实例没有依赖，我们调用set方法，也就是最前面的红色箭头，开始了依赖的处理然后返回Object。

## 后端处理器——Controller

为什么要叫后端处理器呢？因为啊我们的每一个action所对应的就是Controller类里的每个方法，这点可以去action.xml文件中查证。也就是说，在工厂里我们首先通过反射创建的是controller。比如我们登陆，这是User的操作，所对应的也就是UserController类的获取。然后跟据依赖关系获取后几层的对应类。所以Controller的主要工作就是在每个方法内跟据前台和Service层传来的数据将session，业面跳转信息封装到ModelAndView中返回给DispatcherServlet让其进行拆封和跳转。

## 业务的主心骨——Service

Service，中文释义“服务，业务”，可见这部分的内容主要是用来编写业务，你的登录，修改密码等各种操作，其背后的业务逻辑都是在此部分被编写。

## 数据库处理的统一——JDBCTemplate

我们一层一层的传递数据，到了dao层。而dao层也有他们本层的老大JDBCTemplate，每个**dao类小弟提供数据给JDBCTemplate老大,老大拿着Connection这个链接钥匙去数据库这个秘密基地取数据，取完数据再分发给小弟。

为什么我要说只有一个JDBCTemplate呢？

![1573480195666](G:\群硕实训\群硕项目\1573480195666.png)

JDBCTemplate是工厂处理依赖关系时，由getBean方法生成的单例类实例呀。

## 反思

总的说起来，这个框架用到了单例设计模式，动态代理，反射，依赖注入，线程池，可以理解上面所写的内容之后，再专门往深处学习一下。

那为什么要用这个框架呢？

1. 代码复用
2. 代码解耦

其实我们使用框架的理由大部分都是这两个。但对于我来说，对于这次实训项目来说，我没有感觉代码量减少，反而因为改来改去觉得很繁琐，不想使用框架。相信很多同学也有这种感受。这是因为我们是从原生的Servlet代码开始写的，现在所做的事情相当于代码重构，代码重构当然很繁琐。但是当我们直接使用这个框架写项目时，就不会有这种感受了。

首先，common这个package里的代码不止能用于这次的项目，它能用于很多项目。所以在写项目时可以直接导入，一次编写，到处使用，大大减少编码量。其次，这也将可多次复用的代码，和需要我们编写的业务逻辑代码分离，使我们专心于业务核心。代码的解耦，使得我们可以多人协作同一个项目，每个人只要在规范接口情况下注意自己的部分业务就可以了，修改某些因素的时候也不用，牵一发而动全身，到出修改了。